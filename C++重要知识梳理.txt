	数据类型分类
	1.基本数据类型：
		浮点型：
			float、double
		整型：
			长度：short int long longlong
			符号：有符号与无符号
		布尔型：bool
		字符型：char

	2.复合数据类型（引用数据类型）：
		string等
                                struct
	3.举类型：
		枚举类型通常用于为程序中的“一组相关的常量取名字”，以便于程序的可读性和维护性。
		语法：
			1. enum 枚举名称{}
			2. enum class 枚举名称: 符号类型 整型{}
				c++11中需要进行范围限定  一般使用无符号类型 	
	4.空类型：
		void类型 一种特殊的类型，不允许直接使用引用，但是可以声明为指针类型进行空间占位
变量：
	语法格式：数据类型 变量名 = 值；

函数：
	语法格式：
		函数声明：返回值类型 函数名（参数列表）；
		函数定义：返回值类型 函数名（参数列表）{  return 返回值类型对应的值；}	
	函数重载：
		函数名相同，参数列表不同，与返回值类型没有关系。

流程控制语句：
	
	顺序执行：（顺序结构）
		从上到下 从左往右由此执行。

	逻辑分支语句:（选择结构）
		1.if语句:
			if(){}、
			if(){}else{}、
			if(){}else if(){}else{};
		2.switch语句：
			switch (b) {
				case 1: {
					break;
				}
				...
				default: {
				}
			}
	循环语句：（循环结构）
		1.for循环
			for(语句1；布尔表达式；语句2) 语句3
			执行顺序
			语句1-》布尔表达式-》语句3-》语句2-》布尔表达式-》语句3-》语句2.........布尔表达式为false 结束循环
		2. while循环
			while（布尔表达式）语句3
		3.do 语句3 while (布尔表达式)

		*语句3解释： ；或{}
	跳转语句：		
		1.break		结束当前循环
		2.continue	结束当前次循环
		3.return		结束当前函数并返回结果（如果为void 也会进行返回 只不过返回的结果为void类型）
		4.go...to		看到了能认识即可， 作业看到了直接F，没商量

数组：
	同质容器、空间连续、初始化后不可变长。

常量：
	常量的两种定义方式：
		使用const修饰变量
		使用#define 定义

	常量指针（一个常量的指针）：修饰的是int  不能修改int值  也就是指针所指向的那块地址的值 。
		const int * a
	指针常量（指针类型的常量）：修饰的是指针，也就是指针所保存的地址不能变更。
		int * const a = &p; 
		注意：指针常量必须在定义时同时完成初始化。
引用：
	是一个语法糖，在编写的时候更方便。
	查看汇编代码会发现，引用本质其实是一个指针。
	为了方便理解，在引用赋值的时候相当于一下代码替换
		int a = 10;
		int &b = a;
		cout << b << endl;
	等价于：
		int a = 10;
		int * const  b = &a;
		cout << *b << endl;
	测试引用大小要放在结构体种进行测试。引用占用内存同指针。

	引用的本质   	指针常量   	int * const  b = &a;
	常量引用本质是	常量指针常量	const  int * const  b = &a;
左值右值
	左值： 左值指既能够出现在等号左边，也能出现在等号右边的变量；可以被修改，可寻址
	右值： 右值则是只能出现在等号右边的变量，不可以被修改，不可寻址
	
	左值引用：已经在“引用”标题中说明
	右值引用：移动构造函数中使用
	
拷贝构造
	拷贝构造函数的调用时机：
		发生在通过“直接”赋值的方式进行对象初始化时调用。
	深拷贝与浅拷贝的区别：
		浅拷贝：默认调用，会进行数值复制
	·	深拷贝：需要重写，完成指针类型对象的重新生成
	浅拷贝带来的问题；
	在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的，但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，从而导致指针悬挂现象，所以，此时，必须采用深拷贝
	
访问权限修饰符（针对的是访问的位置）
	public：
		修饰访问：全部公开 本类可以访问、子类、类外都可以方位
		修饰继承：保持原本的修饰符不变
	protected：
		修饰访问：本类可以访问、子类可以方位、类外不可以访问
		修饰继承：修改最高权限为protected
	private：
		修饰访问：本类可以访问，子类、类外都不可以访问
		修饰继承：所有权限修改为private
	注意：修饰继承关系时是先继承后再进行保护或隐藏，而不是说把父类的访问修饰符改了

查看继承结构命令：
	cl -d1 reportSingleClassLayout类名 文件绝对路径
	
继承：	
	多继承会带来什么问题？二义性。
	什么是二义性？重复定义，无法确定调用目标。

重载、重写、重定义的区别？
	重载：函数名相同，参数列表不同，与返回值类型没有关系。
	重写（摒弃旧的用新的）：使用虚函数进行函数的重新定义，函数指向会被覆盖。
	重定义（新的旧的都在）：发生在继承关系中，子类可以隐藏重写的行为和属性。

const关键字：
	1. 普通常量：修饰普通类型的变量
	2. 指针常量与常量指针：const 修饰指针变量
		2.1 常量指针（一个常量的指针）
		2.2 指针常量（指针类型的常量）
	3. const参数传递和函数返回值
		3.1 修饰普通参数，同普通常量
		3.2 修饰指针：防止指针指向地址的内容被篡改
		3.3 修饰引用：不可以通过引用修改对象内容。
	4. 修饰返回值
		修饰基本数据类型与没修饰一样。
		修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改
			阻断链式语法
		修饰指针必须使用常量进行接收，引用不需要。
	5. 修饰成员函数：
		防止修改被调用成员函数的值。
		mutable 关键字可以破坏const的保护
static
	静态的属于类，通过类直接调用。只有一份。与对象无关.
	非静态属于对象，通过对象调用。属性有几个对象有几份，函数所有对象公用.
单例设计模式
	全局只有一个对象。
	1. 常见一个自己类型的指针
	2. 提供一个可以获取并初始化指针的静态函数
	3. 私有化构造函数、拷贝构造函数、移动构造函数、等号运算符
	
	
平衡二叉树
	左右子树的高度相差不超过 1 的树为平衡二叉树。
	
函数

	纯函数：纯函数为虚幻的函数，调用无需执行引脚，再蓝图中使用。蓝图中勾选纯函数选项。C++中使用BlueprintPure标记函数。
	虚函数：使用virtual修饰函数，勇于函数重写。本质是对应虚函数表更改函数的指向。
	纯虚函数：使用virtual修饰函数，并将函数置为0（=0），用于封装抽象类。定义了春虚函数的类，无法被直接实例化。需要继承并实现该函数。